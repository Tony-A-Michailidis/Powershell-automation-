<#
    .DESCRIPTION
        Handles the turning on and shutting off of VMs based on 3
        factors: on/off schedule, update schedule, and currently updating

        Schedule: Hourly

    .NOTES
        Version: 3.5
        Author: Alex Imray Papineau
        Last Edit: 08 November 2019
        Editor: Alex Imray Papineau
#>

Param(
    [Parameter(Mandatory = $false, HelpMessage = `
        "The resource group in which to apply the operation, if any")]
    [string]
    $ResourceGroup = "",
    [Parameter(Mandatory = $false, HelpMessage = `
        "When Debug is active, runbook will wait for VM operations to return an output")]
    [switch] $DebugOutput
)

# Prevents runbook from continuing execution if there's an error - Alex
$ErrorActionPreference = "Stop"

# Logging in -> Get connection and use for Az login
$Connection = Get-AutomationConnection -Name "AzureRunAsConnection"
$AzureProfile = Connect-AzAccount `
    -Tenant $Connection.TenantId `
    -CertificateThumbprint $Connection.CertificateThumbprint `
    -ApplicationId $Connection.ApplicationId `
    -ServicePrincipal
$AzureProfile.Context.Subscription

<# Sets three state flags: Startup, Update, and Shutdown
If Startup, VM needs to start
If Update, VM is updating
If Shutdown, VM needs to shutdown
This allows the method's effective ouput to be more complex
without requiring state-specific strings. Method's actual
output will be warning or error messages #>
function Get-VirtualMachineState($vmTagsHash, $TimeZoneTime, `
    [ref] $StartupFlag, [ref] $UpdateFlag, [ref] $ShutdownFlag, $Debug)
{
    $returnString = ""

    # Check that Startup/Shutdown tag values match Regex for time range of 00:00-23:59
    if ($vmTagsHash.keys -icontains "shutdown" -and $vmTagsHash["shutdown"] `
        -match "^([01]?[0-9]|2[0-3]):[0-5][0-9]$")
    {
        # Valid Shutdown tag
        $shutdownTime = [DateTime]$vmTagsHash["shutdown"]
        $DayDiff = $TimeZoneTime.Day - $shutdownTime.Day
        $shutdownTime = $shutdownTime.AddDays($DayDiff)

        if ($Debug)
        { $returnString += "Shutdown time: {0}" -f $shutdownTime }
        
        if ($vmTagsHash.keys -icontains "startup" -and $vmTagsHash["startup"] `
            -match "^([01]?[0-9]|2[0-3]):[0-5][0-9]$")
        {
            # Also valid startup tag
            $startupTime = [DateTime]$vmTagsHash["startup"]
            $DayDiff = $TimeZoneTime.Day - $startupTime.Day
            $startupTime = $startupTime.AddDays($DayDiff)

            if ($Debug)
            { $returnString += "`nStartup time: {0}" -f $startupTime }

            if ($TimeZoneTime -ge $startupTime -and $TimeZoneTime -lt $shutdownTime -and `
                ($TimeZoneTime.DayOfWeek -ne "Saturday" -and $TimeZoneTime.DayOfWeek -ne "Sunday"))
            { $StartupFlag.Value = $true }
            else
            { $ShutdownFlag.Value = $true }
        }
        elseif ($TimeZoneTime -ge $shutdownTime)
        { $ShutdownFlag.Value = $true }
    }

    # Something previously marked this resource as needing a shutdown
    if ($vmTagsHash.keys -icontains "needs_shutdown")
    { $ShutdownFlag.Value = $true }

    #Set our update time to the default.
    $defaultUpdate = "sun_22:00"
    $updateDayPrefix = $defaultUpdate.Split('_')[0]
    $inUpdateTime = [DateTime]$defaultUpdate.Split('_')[1]
    #Check that Update tag value matches Regex for day and time
    if ($vmTagsHash.keys -icontains "update" -and $vmTagsHash["update"].ToLower() `
        -match "^(mon|tue|wed|thu|fri|sat|sun)_([01]?[0-9]|2[0-3]):00$")
    {
        #Overwrite the default time with the vm specified time.
        $updateDayPrefix = $vmTagsHash["update"].Split('_')[0]
        $inUpdateTime = [DateTime]$vmTagsHash["update"].Split('_')[1]
    }
    if ($Debug)
    { $returnString += "`nUpdate time: {0}" -f $inUpdateTime }
    $timeUpdateDiff = $TimeZoneTime - $inUpdateTime
    # The timeslot length should match the interval between scheduler.ps1
    # runs -> more edge cases may need to be handled otherwise
    $timeSlotLength = New-TimeSpan -Minutes 59

    # Check for Update_State tag, which indicates an update is
    # happening or is finished (and takes priority over timeslot)
    if ($vmTagsHash.keys -icontains "update_state")
    {
        if ($vmTagsHash["update_State"].ToLower() -ne "ready" `
            -or $timeUpdateDiff -lt (New-TimeSpan -Minutes 110))
        { $UpdateFlag.Value = $vmTagsHash["update_state"].ToLower() -ne "done" }
        else
        {
            $returnString += ("WARNING! Resource was running in Update State 'ready' for" `
                + " nearly 2 hours. Update service may not be running on this resource.")
        }
    }
    # Check if we're within this Resource's Update timeslot
    elseif ($TimeZoneTime.DayOfWeek.ToString().ToLower().Contains($updateDayPrefix) -and `
        $timeUpdateDiff.TotalMinutes -ge 0 -and $timeUpdateDiff -lt $timeSlotLength)
    { $UpdateFlag.Value = $true }

    return $returnString
}

$CurrentDate = Get-Date
$timeZoneIDs = @{
    "PST"               ="Pacific Standard Time";
    "MST"               ="Mountain Standard Time";
    "CST"               ="Central Standard Time";
    "EST"               ="Eastern Standard Time";
    "AST"               ="Atlantic Standard Time";
    "NST"               ="Newfoundland Standard Time";
    "UTC"               ="UTC";
    "GMT"               ="Greenwich Standard Time";
}

if ($ResourceGroup -eq "")
{
    "Retrieving VMs in {0} at {1}..." `
        -f $Profile.Context.Subscription, $CurrentDate
    $VirtualMachines = @(Get-AzVM)
}
else
{
    "Retrieving VMs in {0} within {1} at {2}..." `
        -f $ResourceGroup, $Profile.Context.Subscription, $CurrentDate
    $VirtualMachines = @(Get-AzVM -ResourceGroupName $ResourceGroup)
}
"Processing {0} VMs..." -f $VirtualMachines.Count

$failedVM = $false
$failureMessage = "+++ Error messages +++"

# Iterate through VMs and update state according to tags
foreach ($VMachine in $VirtualMachines) 
{
    # Reset variables
    $tagsHash = [System.Collections.Specialized.CollectionsUtil]::CreateCaseInsensitiveHashtable($VMachine.Tags)
    $ScheduleTimeZone = "EST"
    $needsStartup = $false
    $inUpdateTime = $false
    $needsShutdown = $false
    $VmMessage = ""

    # Get the VM's local time based on its timezone
    if ($tagsHash.keys -icontains "schedule" -and $tagsHash["schedule"].length -eq 3)
    { $ScheduleTimeZone = $tagsHash["schedule"].ToUpper() }
    $LocalTime = [System.TimeZoneInfo]::ConvertTimeBySystemTimeZoneId(`
        $CurrentDate, $timeZoneIDs[$ScheduleTimeZone])

    # Skip if 'Schedule' tag missing or 'false', and if not in default update time
    if ($LocalTime.DayOfWeek -ne "Sunday" -or $LocalTime.Hour -ne "22")
    {
        if ($tagsHash.keys -notcontains "schedule" -or `
            $tagsHash["schedule"].ToLower() -eq "false")
        {
            $VmMessage += "{0} is unscheduled. Skipping..." -f $VMachine.Name
            $VmMessage
            continue
        }
    }
    $VmMessage = "=== {0} ===`n" -f $VMachine.Name
    $VmMessage += "On {0} schedule. Local time: {1}" `
        -f $ScheduleTimeZone, $LocalTime.ToString()

    if ($DebugOutput)
    { $tagsHash }

    # Check if VM state
    $VmStateMessage = Get-VirtualMachineState `
        -VmTags $tagsHash `
        -TimeZoneTime $LocalTime `
        -Startup ([ref]$needsStartup) `
        -Update ([ref]$inUpdateTime) `
        -Shutdown ([ref]$needsShutdown)
    $VmMessage += "`nStartup={0} Shutdown={1} Update={2}" `
        -f $needsStartup, $needsShutdown, $inUpdateTime

    # Error message output
    if ($VmStateMessage -ne "" -and $DebugOutput)
    { $VmMessage += "`nMessage: {0}" -f $VmStateMessage }

    # A schedule or an update marked the resource as needing shutdown
    if ($needsShutdown)
    {
        if ($inUpdateTime)
        {
            if ($tagsHash.keys -inotcontains "needs_shutdown")
            {
                $VMachine.Tags.Add("needs_shutdown", "") | Out-Null
                $VmMessage += "`n  Action: Added 'Needs_Shutdown' tag"
            }
        }
        else
        {
            try {
                $VmInstance = Get-AzVM -Status -ResourceGroupName `
                    $VMachine.ResourceGroupName -Name $VMachine.Name
            }
            catch {
                "`nScheduling VM '{0}' failed. Could not get instance view. Error:`n{1}`n{2}`n" `
                    -f $VMachine.Name, $_, $_.ScriptStackTrace
                $failedVM = $true
                continue
            }

            if ($VmInstance.Statuses.DisplayStatus.Contains("VM running") -and !$needsStartup)
            # The last !$needsStartup is in case ansible fails to shutdown the VM.
            # It prevents vm shutdown & startup in same scheduler run
            {
                if ($DebugOutput)
                {
                    $VmMessage += "`n" + ((Stop-AzVM -ResourceGroupName `
                        $VMachine.ResourceGroupName -Name $VMachine.Name `
                        -Force) | Out-String)
                }
                else
                {
                    Stop-AzVM -ResourceGroupName $VMachine.ResourceGroupName `
                        -Name $VMachine.Name -Force -AsJob | Out-Null
                }
                $VmMessage += "`n  Action: Shutdown VM"
            }

            if ($tagsHash.keys -icontains "needs_shutdown")
            {
                $VMachine.Tags.Remove("needs_shutdown") | Out-Null
                $VmMessage += "`n  Action: Removed 'needs_shutdown' tag"
            }
        }
    }

    # Resource needs starting, either due to schedule or update timeslot
    if ($needsStartup -or $inUpdateTime)
    {
        try {
            $VmInstance = Get-AzVM -Status -ResourceGroupName `
                $VMachine.ResourceGroupName -Name $VMachine.Name
        }
        catch {
            "`nScheduling VM '{0}' failed. Could not get instance view. Error:`n{1}`n{2}`n" `
                -f $VMachine.Name, $_, $_.ScriptStackTrace
            $failedVM = $true
            continue
        }

        if (!$VmInstance.Statuses.DisplayStatus.Contains("VM running"))
        {
            if ($DebugOutput)
            { $VmMessage += "`n" + ((Start-AzVM -Id $VMachine.Id) | Out-String) }
            else
            { Start-AzVM -Id $VMachine.Id -AsJob | Out-Null }
            $VmMessage += "`n  Action: Started VM"
        }
        # This is to handle when $needsStartup is true during an update timeslot
        elseif ($needsStartup -and $tagsHash.keys -icontains "needs_shutdown")
        {
            $VMachine.Tags.Remove("needs_shutdown") | Out-Null
            $VmMessage += "`n  Action: Removing 'needs_shutdown' tag"
        }
    }

    # Resource is starting or finishing an update
    if ($inUpdateTime)
    {
        if ($tagsHash.keys -inotcontains "update_state")
        {
            $VMachine.Tags.Add("update_state", "ready") | Out-Null
            $VmMessage += "`n  Action: Adding 'update_state : ready' tag"
        }
    }
    elseif ($tagsHash.keys -icontains "update_state")
    {
        $VMachine.Tags.Remove("update_state") | Out-Null
        $VmMessage += "`n  Action: Removing 'update_state' tag"
    }

    try {
        # Update the VM's tags, output activity summary for this VM
        if ($DebugOutput)
        {
            $VmMessage += "`n" + ((Update-AzVM `
                -Id $VMachine.Id -VM $VMachine `
                -Tag $VMachine.Tags) | Out-String)
        }
        else
        {
            Update-AzVM -Id $VMachine.Id -VM $VMachine `
                -Tag $VMachine.Tags -AsJob | Out-Null
        }
    }
    catch {
        "`nScheduling VM '{0}' failed. Could not update VM. Error:`n{1}`n{2}`n" `
            -f $VMachine.Name, $_, $_.ScriptStackTrace
        $failedVM = $true
        continue
    }
    $VmMessage
}

if ($failedVM)
{
    Write-Output $failureMessage
    throw
}