<#
  .DESCRIPTION
    Gets existing virtual machine state and schedule-related tags.
    Passes the information on to Set-VmScheduleState child runbook.

    Schedule-run, half-hourly

  .NOTES
    Version: 3.0
    Author: Alex Imray Papineau
    Last Edit: 10 March 2020
    Editor: Alex Imray Papineau
#>

Param(
  [Parameter(Mandatory = $false, HelpMessage = `
    "The resource group in which to apply the operation, if any")]
  [string] $ResourceGroup = ""
)

# Prevents runbook from continuing execution if there's an error - Alex
$ErrorActionPreference = "Stop"

# Logging in -> Get connection and use for Az login
$connection = Get-AutomationConnection -Name "AzureRunAsConnection"
$azureProfile = Connect-AzAccount `
  -Tenant $connection.TenantId `
  -CertificateThumbprint $connection.CertificateThumbprint `
  -ApplicationId $connection.ApplicationId `
  -ServicePrincipal
"Logged in to subscription '{0}'" `
  -f $azureProfile.Context.Subscription.Name

# Retrieve necessary automation variables
$autoAccountName = Get-AutomationVariable -Name 'AutoAccountName'
$autoAccountRG = Get-AutomationVariable -Name 'AutoAccountRG'
"Retrieved automation variables:`nAutomation account name: {0}`nAutomation account RG: {1}" `
  -f $autoAccountName, $autoAccountRG

# Retrieve VMs
$virtualMachines = @()
if ($ResourceGroup -ne "")
{ $virtualMachines = @(Get-AzVM -ResourceGroupName $ResourceGroup) }
else
{ $virtualMachines = @(Get-AzVM) }

if ($virtualMachines.Length -le 0)
{
  "No VMs found for processing. Exiting."
  exit
}
else
{ "Retrieved {0} vms to process" -f $virtualMachines.Length }

# Retrieve VM status views
$vmStatuses = @()
if ($ResourceGroup -ne "")
{ $vmStatuses = @(Get-AzVM -ResourceGroupName $ResourceGroup -Status) }
else
{ $vmStatuses = @(Get-AzVM -Status) }

# Get VM names and set hashtables
$vmNames = @()
$namesAndVms = @{}
$namesAndPowerStates = @{}
foreach ($vm in $virtualMachines)
{
  $namesAndVms.Add($vm.Name, $vm)
  $vmNames += $vm.Name
}
foreach ($vmView in $vmStatuses)
{ $namesAndPowerStates.Add($vmView.Name, $vmView.PowerState) }
$vmNames = $vmNames | Sort-Object

"Names of VMs to process:`n{0}" -f $vmNames

# Init constant variables
$currentTime = Get-Date
$updateSpan = New-TimeSpan -Minutes 59      # Even though it's every half-hour
# $updateMaxSpan = New-TimeSpan -Minutes 119   # Stop updates longer than 2 hours
$namesAndJobIds = @{}
$jobIdsAndJobs = @{}
$noChildJob = @()
$textInfo = (Get-Culture).TextInfo          # Needed for capitalization
$daysOfWeek = @{
  'sun' = [System.DayOfWeek]::Sunday;
  'mon' = [System.DayOfWeek]::Monday;
  'tue' = [System.DayOfWeek]::Tuesday;
  'wed' = [System.DayOfWeek]::Wednesday;
  'thu' = [System.DayOfWeek]::Thursday;
  'fri' = [System.DayOfWeek]::Friday;
  'sat' = [System.DayOfWeek]::Saturday;
}

#Process VMs
foreach ($vName1 in $vmNames)
{
  # Init vm-specific variables
  $updateTagVal = "sun_22:00"
  $timeZonePrefix = "Eastern"
  $timeZoneFull = ""
  $tagsHash = [System.Collections.Specialized.CollectionsUtil]::CreateCaseInsensitiveHashtable(`
    $namesAndVms[$vName1].Tags)
  # Below are passed to child runbook
  $vmRunning = $false
  $vmUpdating = $false
  $vmHasSchedule = $false
  $vmStartup = $null
  $vmShutdown = $null

  # Get the VM's power state
  if ($namesAndPowerStates[$vName1].Contains("running"))
  { $vmRunning = $true }

  # Get VM timezone, and current time in that timezone
  if ($tagsHash.keys -icontains "schedule" -and $tagsHash["schedule"].ToLower() -match `
    "^(pacific|mountain|central|eastern|atlantic|newfoundland|greenwich)$")
  { $timeZonePrefix = $textInfo.ToTitleCase($tagsHash['schedule'].ToLower()) }

  $timeZoneFull = $timeZonePrefix + " Standard Time"
  $vmTime = [System.TimeZoneInfo]::ConvertTimeBySystemTimeZoneId($currentTime, $timeZoneFull)
  if ($vmTime.IsDaylightSavingTime())
  {
    $vmTime = $vmTime.AddHours(1)
    $timeZoneFull = $timeZoneFull.Replace("Standard", "Daylight")
  }

  # Check if already updating
  if ($tagsHash.keys -icontains "update_state" -and `
    $tagsHash["update_state"].ToLower() -ne "done")
  { $vmUpdating = $true }
  # Check for custom update period
  elseif ($tagsHash.keys -icontains "update" -and $tagsHash["update"].ToLower() `
    -match "^(mon|tue|wed|thu|fri|sat|sun)_([01]?[0-9]|2[0-3]):[0-5][05]$")
  {
    # Extract specified update day and time
    $updateTagVal = $tagsHash["update"].ToLower()
    $updateTime = [DateTime]$updateTagVal.Split('_')[1]
    $dayDiff = (7 + ($updateTime.DayOfWeek - `
      $daysOfWeek[$updateTagVal.Split('_')[0]])) % 7
    $updateTime = $updateTime.AddDays(-1 * $dayDiff)
    $updateDiff = $vmTime - $updateTime

    # Check if within update time period
    if ($updateDiff.TotalMinutes -ge 0 -and `
      $updateDiff -lt $updateSpan -and `
      $vmTime.DayOfWeek.ToString().ToLower().Contains($updateTagVal.Split('_')[0]))
    { $vmUpdating = $true }
  }

  # Get variables to pass to child runbook
  if ($tagsHash.keys -icontains "startup" -and `
  $tagsHash["startup"] -match "^([01]?[0-9]|2[0-3]):[0-5][0-9]$")
  { $vmStartup = $tagsHash["startup"] }

  if ($tagsHash.keys -icontains "shutdown" -and `
  $tagsHash["shutdown"] -match "^([01]?[0-9]|2[0-3]):[0-5][0-9]$")
  { $vmShutdown = $tagsHash["shutdown"] }

  if ($tagsHash.keys -icontains "schedule" -and `
    $null -ne $vmShutdown)
  { $vmHasSchedule = $true }

  # Package variables to pass to child runbook
  $runbookArgs = @{ `
    "VmName" = $vName1; `
    "VmRG" = $namesAndVms[$vName1].ResourceGroupName; `
    "IsRunning" = $vmRunning; `
    "ScheduleZone" = $timeZoneFull; `
    "StartupTime" = $vmStartup; `
    "ShutdownTime" = $vmShutdown
  }

  if ($vmUpdating -or !$vmHasSchedule)
  { $noChildJob += $vName1 }
  else
  {
    # Start child runbook as separate task
    $runbookJob = Start-AzAutomationRunbook `
      -Name "Set-VmScheduleState" `
      -AutomationAccountName $autoAccountName `
      -ResourceGroupName $autoAccountRG `
      -Parameters $runbookArgs
    "Started child runbook for '{0}' at {1}`nJob ID: {2}" `
      -f $vName1, $runbookJob.CreationTime, $runbookJob.JobId
  
    $namesAndJobIds.Add($vName1, $runbookJob.JobId)
    $jobIdsAndJobs.Add($runbookJob.JobId, $null)
  }
}

# Ouput vm names that don't have child jobs
if ($noChildJob.Length -gt 0)
{
  $noJobMessage = "The following VMs are either updating or do not have a schedule:"
  foreach ($vName4 in $noChildJob)
  { $noJobMessage += "`n - {0}" -f $vName4 }
  $noJobMessage

  $validNames = @()
  foreach ($vName5 in $vmNames)
  { 
    if (!$noChildJob.Contains($vName5))
    { $validNames += $vName5 }
  }
  $vmNames = $validNames
}

# Get the job details
$allJobsDone = $false
$autoJob = $null
$cycleCount = 0

# Wait loop
while(!$allJobsDone)
{
  $allJobsDone = $true
  foreach ($jobId in $namesAndJobIds.Values)
  {
    if (!$allJobsDone)
    { break }

    if ($null -eq $jobIdsAndJobs[$jobId])
    {
      $autoJob = Get-AzAutomationJob -ResourceGroupName $autoAccountRG `
        -Id $jobId -AutomationAccountName $autoAccountName

      if ($autoJob.Status -eq 'Completed' -or `
        $autoJob.Status -eq 'Failed' -or `
        $autoJob.Status -eq 'Stopped')
      { $jobIdsAndJobs[$jobId] = $autoJob }
      else
      { $allJobsDone = $false }
    }
  }

  $cycleCount++
  "Cycle {0}..." -f $cycleCount
  Start-Sleep -Seconds 30
}

# Set variables
$vmAutoJobs = @{}
$jobInf = $null
$schedStateMessage = ""
$actionsMessage = ""

"Sorting jobs..."

# Sort job infos
foreach ($vName2 in $vmNames)
{ $vmAutoJobs.Add($vName2, $jobIdsAndJobs[$namesAndJobIds[$vName2]]) }

"================================================="

foreach ($vName3 in $vmNames)
{
  # Get job info
  $jobInf = $vmAutoJobs[$vName3]

  # Retrieve outputs
  $outputs = @(Get-AzAutomationJobOutput `
    -Id $jobInf.JobId `
    -ResourceGroupName $jobInf.ResourceGroupName `
    -AutomationAccountName $jobInf.AutomationAccountName)
  $schedStateMessage = $outputs[$outputs.Length - 2].Summary
  $actionsMessage = $outputs[$outputs.Length - 1].Summary

  # Output VM summary
  if ($jobInf.Status -eq "Failed")
  {
    "'{0}' failed to complete its job: {1}`n{2}" `
      -f $vName3, $jobInf.JobId, $jobInf.Exception
  }
  else
  {
    "'{0}' ({1}), scheduled {2}, job: {3}`n  {4}" -f $vName3, `
      $namesAndPowerStates[$vName3], $schedStateMessage, `
      $jobInf.JobId, $actionsMessage
  }
}